---
layout: post
title: "反思 | 低级错误案例"
date:   2024-01-13
comments: true
toc: true
tags: [总结]
author: NY2025xyc
---

## Part 0 前言

> ~~谢某一世英名尽毁于此。~~
> 
> 最近考试有个奇怪现象：推式子、想思路顺理成章，一写代码就挂分，特此总结，引以为戒。
>
> 持续扩充中，更新的机会估计很多 ^_^。

## Part 1 审题

### 1.1 基础 | 关键信息

不论是 `OI` 还是综合，审题不细估计是永远的痛。慢下来、细下来，审题环节多花的十多分钟，可能会为接下来推导思路和 `DEBUG` 节约半个小时以上的时间。

---

##### EXAMPLE 1.1.1 Erase First or Second Letter

> You are given a string $s$ of length $n$. Let's define two operations you can apply on the string:
>
> - remove the first character of the string;
> - remove the **second** character of the string.
>
> Your task is to find the number of distinct non-empty strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.

作为一道思维题，这道题经过大概的手动模拟就不难发现规律：

$$
rst=\sum_{i=1}^{n}f_{s[1:i]}
$$

其中 $f$ 函数表示一个字符串中不同字母的数量，$s[l:r]$ 表示 $s$ 在 $[l, r]$ 区间内的子串。

而手动加黑的 **second** 便是赛时审题错误之处，我在比赛过程中将其读成 **last** 导致浪费了将近一个小时的时间。遂怀疑 `Div. 2` 的 `B` 题为何难度就高至于如此，重新读题，恍然大悟，十分钟不到切了……

因为这道题彻底没有时间开 `C`，成了历次 `Codeforces` 中发挥最差的一次。

---

##### EXAMPLE 1.1.2 Jellyfish and EVA

> Monsters have invaded the town again! Asuka invites her good friend, Jellyfish, to drive EVA with her.

> There are $n$ cities in the town. All the monsters are in city $n$. Jellyfish and Asuka are currently in city $1$ and need to move to city $n$ to defeat the monsters.

> There are $m$ roads. The $i$-th road allows one to travel from city $a_i$ to city $b_i$. All the roads are directed. That is, one cannot travel from city $b_i$ to $a_i$ using the $i$-th road. Interestingly, all roads satisfy $\color{red}a_i<b_i$.

> Driving EVA requires two people to work together. However, Asuka and Jellyfish have not done any training together before.

> Suppose that EVA is currently in city $u$. Jellyfish and Asuka will both choose an undestroyed road that starts at city $u$. Suppose Jellyfish and Asuka choose roads that end at cities $v_1$ and $v_2$ respectively. If $v_1=v_2$, EVA moves to city $v_1$ successfully. Otherwise, EVA stays in city $u$ and both roads that they have chosen will be destroyed.

> It is possible that EVA is currently in city $u(u≠n)$ and there are no undestroyed roads that start at city $u$. In that case, the mission will be a failure. Otherwise, if they reach city $n$ in the end, the mission is considered a success.

> Every time they choose the roads, Jellyfish knows that Asuka will choose a road randomly. Now, Jellyfish wants to know, if she chooses the roads optimally, what is the maximum probability of the mission being successful.

这道题整体思路稍微复杂，但不难想到：

$$
f_u=\sum_{i=1}^{k}p_i\times f_{v_i}
$$

$f_{v}$ 为 $f_u$ 的出边集合。其中 $p_i$ 是能够使得 $f_u$ 取到最大值的系数集合。根据排序不等式，若满足 $f_{v_i}>f_{v_j}(\forall 1\leq i < j \leq k)$，则 $p$ 序列也应当从大到小排序。

容易得到 $p$ 序列只与 $k$ 有关，故而设 $p(k)$ 表示长度为 $k$ 时最优的 $p$ 序列。

得到转移如下：

$$
p(k)_1 = \frac{1}{k}
$$

$$
p(k)_i = \frac{i-2}{k}\times p(k-2)_{i-2}+\frac{k-i}{k}\times p(k-2)_{i-1}
$$

以上的内容在考试时均已推出，虽然没有想到预处理 $p(k)$。对于 $f_u$ 的转移，应当按照常规套路以 `DAG` 的拓扑序转移，至于为何是 `DAG`，题干中被我加红的 $\color{red}a_i<b_i$ 很明确地说明了这一点。

然而，考试时很荣幸地没有看到（因为题面太长跳行阅读），于是用 `Dijkstra` 一通乱搞……

---

**总结** 审题在题面信息提取大致有如下注意点：

1. 第一次审题能够带给最深刻的印象，因而在第一次审题时一定要慢下来，逐字逐行阅读，不因题目背景繁琐冗长而跳过其中分布稀疏却极其有用的关键信息 [对应 EXAMPLE 1.1.2]
2. 在阅读时看到数字、数据范围、公式等条件，应当在 PDF 中勾画或抄在纸上，避免忽略、遗忘或者错误记忆 [对应 EXAMPLE 1.1.1 & 1.1.2]
3. 当题目做不出或者解法明显超出该考试的难度范围时，首先采取措施不是重新思考，而是重新读题 [对应 EXAMPLE 1.1.1]

### 1.2 进阶 | 思路相关

有些题目中给定的特殊限制条件将会给思考方向提供极大程度的便利，将注意力放到这些条件上，问题往往迎刃而解。审题时，对于有别于其他题目的特殊限制应当加倍注意。

---

##### EXAMPLE 1.2.1 Graph and String

> One day student Vasya was sitting on a lecture and mentioned a string $s_1,s_2,..., s_n$, consisting of **letters "a", "b" and "c"** that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph G with the following properties:
>
> - G has exactly $n$ vertices, numbered from $1$ to $n$.
> - For all pairs of vertices $i$ and $j$, where $i\neq j$, there is an edge connecting them if and only if characters $s_i$ and $s_j$ are either equal or neighbouring in the alphabet. That is, letters in pairs "a"-"b" and "b"-"c" are neighbouring, while letters "a"-"c" are not.
>
> Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph $G$, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string s, such that if Vasya used this s he would produce the given graph $G$.

这道题的关键突破口就在于审题能否注意到字符集大小只有 $3$，手动加黑的那句话恰恰说明了这一点。

此时可以知道所有的字符 `'b'` 结点到除它本身以外的所有点均有连边，而将这些边删掉之后，剩下的点和边若构成两个集合且均为完全图，则任意能选择一个集合作为字符 `'a'` 的集合，另一个集合作为字符 `'c'` 的集合（允许空集存在）。

而在练习过程中耗费大量时间的原因也就是没有注意到字符集大小，按照全体小写字母进行处理。

事实上，对于字符集限定于小写字母（甚至是小写字母的特定子集，比如这道题）或者值域小于 $100$ 的限定条件，往往是在提示一种特殊的解决方案。

字符集拓展到 $26$ 个英文小写字母能否完成这道题？想必很复杂。故而有在文章 [【反思】10月&11月考场表现](https://www.luogu.com.cn/blog/NY2025/post-fan-sai-10-yue-11-yue-kao-chang-biao-xian) 中提到的审题和思考方法：尝试去掉一些限定条件并思考会产生什么影响。

---

**总结** 审题时可以尝试逐个看当前限定条件去掉后会产生什么影响，在帮助审题深入细致、不遗漏信息的同时，也能帮助思路的形成。

## Part 2 实现

### 2.1 初始化

众所周知，多测不清空是极其常见的错误。想起多测清空/初始化也不一定能保证不因此挂分，不同的清空方式可能造成不同的结果，一些细节有时会影响全局的解答。

---

##### EXAMPLE 2.1.1 Subset with Zero Sum 

> You are given $n$ integers $a_1,a_2,…,a_n$, such that for each $1\leq i \leq n$ holds $i-n\leq a_i \leq i-1$.
>
> Find some nonempty subset of these integers, whose sum is equal to $0$. It can be shown that such a subset exists under given constraints. If there are several possible subsets with zero-sum, you can find any of them.

附上输入声明：

> Each test contains multiple test cases. The first line contains the number of test cases $t(1\leq t\leq 10^6)$. The description of the test cases follows.
>
> The first line of each test case contains a single integer $n(1\leq n\leq 10^6)$.
>
> The second line of each test case contains $n$ integers $a_1,a_2,…,a_n(i-n\leq a_i\leq i-1)$.
>
> It is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.

经过较为复杂的推导证明可以得到，在序列中连接节点 $i\rightarrow i - a[i]$，可以构成基环内向树森林，其中任意一个环上的所有节点构成一个和为零的集合。

找环时显然有标记数组 `vis`。

在清空 `vis` 时，最初我采取了最常见的清空方式，调用 `memset()` 函数，代码如下：

```c++
while (t--) {
	q.clear();
   	memset(vis, 0, sizeof vis);
   // 核心代码
}
```

然而事实上，`sizeof(vis)` 应为定值 $10^6\times 4$ `byte`，$t$ 的最大值能够达到 $10^6$，故而清空时的时间复杂度应是平方级别的，就算 `memset` 的常数极小，也显然会超时。

题目给出条件有所有 $n$ 的总和小于等于 $10^6$，所以手动循环清空，时间复杂度反而应为线性的。正确代码如下：

```c++
while (t--) {
	q.clear();
   	for (int i = 1; i <= n; i++) {
		vis[i] = false;
   	}
}
```

~~(当然其实有打时间戳这种常数复杂度且不用清空的方式优化，参考二分图)~~

---

##### PAY ATTENTION 2.1.2 老生常谈的错误

- 多测不清空
- 初始化值太大导致后续操作溢出
- `ST` 表等初始化时越界访问
- ……（等犯了错再来更）

---

**总结** 初始化清空大致有如下注意点：

1. 多测清空。
2. 清空数组时应当分清情况，考虑实际需求，不能盲目地使用 `memset`，尽管在绝大部分情况下，`memset` 都是最优选择。[对应 EXAMPLE 2.1.1]
3. 不盲目使用 `INT_MAX`、`memset(a, 63, sizeof a)` 之类方式赋值，尤其是涉及到动态规划的状态转移方程一类问题，无解情况仍有加减等操作，这时极易发生整型溢出。
